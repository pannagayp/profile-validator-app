/**
 * @fileoverview Firestore Security Rules for Email Fetching App.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user profiles and raw emails.
 * Public read access is granted to the `extracted-profiles-test`, `verification-test`,
 * and `profiles-verified` collections, while writes are generally disallowed (with TODO placeholders
 * to signal the need for future ownership validation).
 *
 * Data Structure:
 * - /users/{userId}/profiles/{profileId}: Stores user profile data.
 * - /users/{userId}/raw-emails-test/{emailId}: Stores raw email data.
 * - /extracted-profiles-test/{profileId}: Stores extracted profile data.
 * - /verification-test/{verificationId}: Stores verification results.
 * - /profiles-verified/{profileId}: Stores verified profiles.
 *
 * Key Security Decisions:
 * - User data is segregated under the `/users/{userId}` path to ensure privacy.
 * - `list` operations are allowed for owners in their respective user subcollections (e.g., `/users/{userId}/raw-emails-test`).
 * - Public read access is granted to the top-level collections for extracted profiles and verification results to allow global visibility.
 * - Write access to the public collections is initially denied and marked with `TODO` to highlight the need for adding ownership validation logic in the future.
 *
 * Denormalization for Authorization:
 * The 'RawEmail' documents contain a 'userProfileId' field. This denormalization is in place to allow
 * authorization checks on the email documents without needing to perform additional `get()` requests to
 * the user's profile. This greatly improves the performance and simplicity of the security rules.
 *
 * Structural Segregation:
 * User-specific data (profiles and raw emails) are stored under the `/users/{userId}` path, providing
 * a clear separation between private user data and public data. This structural segregation is used
 * to simplify `list` operations, ensuring that users can only list data associated with their own user ID.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profile data, allowing only the owner to read and write.
     * @path /users/{userId}/profiles/{profileId}
     * @allow (create) User 'user123' can create a profile with profileId 'profile456' under /users/user123/profiles/profile456.
     * @allow (update) User 'user123' can update their profile under /users/user123/profiles/profile456.
     * @allow (delete) User 'user123' can delete their profile under /users/user123/profiles/profile456.
     * @allow (get) User 'user123' can get their profile under /users/user123/profiles/profile456.
     * @allow (list) User 'user123' can list profiles under /users/user123/profiles.
     * @deny (create) User 'user456' cannot create a profile under /users/user123/profiles/profile456.
     * @deny (update) User 'user456' cannot update the profile under /users/user123/profiles/profile456.
     * @deny (delete) User 'user456' cannot delete the profile under /users/user123/profiles/profile456.
     * @deny (get) User 'user456' cannot get the profile under /users/user123/profiles/profile456.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/profiles/{profileId} {
      // Allow reads by the owner
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      // Allow creation only if the user is creating their own profile and the userId matches the profileId.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;

      // Allow updates and deletes only if the user is the owner and the document exists
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Protects raw email data, allowing only the owner to read and write.
     * @path /users/{userId}/raw-emails-test/{emailId}
     * @allow (create) User 'user123' can create an email with emailId 'email456' under /users/user123/raw-emails-test/email456.
     * @allow (update) User 'user123' can update their email under /users/user123/raw-emails-test/email456.
     * @allow (delete) User 'user123' can delete their email under /users/user123/raw-emails-test/email456.
     * @allow (get) User 'user123' can get their email under /users/user123/raw-emails-test/email456.
     * @allow (list) User 'user123' can list emails under /users/user123/raw-emails-test.
     * @deny (create) User 'user456' cannot create an email under /users/user123/raw-emails-test/email456.
     * @deny (update) User 'user456' cannot update the email under /users/user123/raw-emails-test/email456.
     * @deny (delete) User 'user456' cannot delete the email under /users/user123/raw-emails-test/email456.
     * @deny (get) User 'user456' cannot get the email under /users/user123/raw-emails-test/email456.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/raw-emails-test/{emailId} {
      // Allow reads by the owner
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userProfileId == userId;

      // Allow updates and deletes only if the user is the owner and the document exists
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userProfileId == resource.data.userProfileId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to extracted profiles, but restricts write access.
     * @path /extracted-profiles-test/{profileId}
     * @allow (get) Any user can retrieve extracted profile data.
     * @allow (list) Any user can list extracted profile data.
     * @deny (create) No user can create extracted profiles without validation (TODO).
     * @deny (update) No user can update extracted profiles without validation (TODO).
     * @deny (delete) No user can delete extracted profiles without validation (TODO).
     * @principle Public read access with restricted writes, pending ownership validation.
     */
    match /extracted-profiles-test/{profileId} {
      // Allow public read access
      allow get: if true;
      allow list: if true;

      // CRITICAL: Cannot implement owner-only writes. The 'ExtractedProfile' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to verification results, but restricts write access.
     * @path /verification-test/{verificationId}
     * @allow (get) Any user can retrieve verification results.
     * @allow (list) Any user can list verification results.
     * @deny (create) No user can create verification results without validation (TODO).
     * @deny (update) No user can update verification results without validation (TODO).
     * @deny (delete) No user can delete verification results without validation (TODO).
     * @principle Public read access with restricted writes, pending ownership validation.
     */
    match /verification-test/{verificationId} {
      // Allow public read access
      allow get: if true;
      allow list: if true;

      // CRITICAL: Cannot implement owner-only writes. The 'VerificationResult' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to verified profiles, but restricts write access.
     * @path /profiles-verified/{profileId}
     * @allow (get) Any user can retrieve verified profile data.
     * @allow (list) Any user can list verified profile data.
     * @deny (create) No user can create verified profiles without validation (TODO).
     * @deny (update) No user can update verified profiles without validation (TODO).
     * @deny (delete) No user can delete verified profiles without validation (TODO).
     * @principle Public read access with restricted writes, pending ownership validation.
     */
    match /profiles-verified/{profileId} {
      // Allow public read access
      allow get: if true;
      allow list: if true;

      // CRITICAL: Cannot implement owner-only writes. The 'VerifiedProfile' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the resource.
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  // Helper function to determine if the user is the owner of the resource AND the resource exists.
  function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
  }
}